# 소트
 
|시간 제한|	메모리 제한|	제출|	정답|	맞힌 사람|	정답 비율|
|----|--------|-------|-----|-------|--------|
|2 초|	128 MB|	11402|	2842|	2278|	27.710%|

## 문제

크기가 N인 배열 A가 있다. 배열에 있는 모든 수는 서로 다르다. 이 배열을 소트할 때, 연속된 두 개의 원소만 교환할 수 있다. 그리고, 교환은 많아봐야 S번 할 수 있다. 이때, 소트한 결과가 사전순으로 가장 뒷서는 것을 출력한다.

## 입력

첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 원소가 차례대로 주어진다. 이 값은 1000000보다 작거나 같은 자연수이다. 마지막 줄에는 S가 주어진다. S는 1000000보다 작거나 같은 음이 아닌 정수이다.

## 출력

첫째 줄에 문제의 정답을 출력한다.

### 예제 입력 1 

```
7
10 20 30 40 50 60 70
1
```

### 예제 출력 1 

```
20 10 30 40 50 60 70
```

### 예제 입력 2 

```
5
3 5 1 2 4
2
```

### 예제 출력 2 

```
5 3 2 1 4
```

### 예제 입력 3 

```
10
19 20 17 18 15 16 13 14 11 12
5
```

### 예제 출력 3 

```
20 19 18 17 16 15 14 13 12 11
```

### 문제 출처

- [백준 소트 문제](https://www.acmicpc.net/problem/1083)

### 문제 풀이 방식

문제에서 사전 순으로 가장 뒷선 다는 표현은 S 번 정렬한 여러가지 경우의 수들을 사전 순으로 정렬한 것들을 비교했을 때 가장 큰 수가 제일 앞 쪽에 배치된 것을 찾으라는 의미였다.( 설명 한 번 어렵네... )
그렇다보니 처음에는 (0+S) 까지의 수들 중에서 가장 큰 수를 먼저 찾고, 그 수를 0번 자리로 오게 만들어줘야한다.
그러기 위해서 가장 큰 수의 인덱스인 maxPos를 찾고, maxPos부터 0번까지 연속된 수를 바꾸는 식으로 하나씩 진행을 해준다. 다음 인덱스인 1번부터 (1+남은 S)까지에서 인덱스 0번의 수 다음으로 큰 수를 찾아가고, 그 수를 1번 인덱스로 옮기는 식으로 S가 0이 될 때까지 계속 진행을 해주면 소트(정렬)을 완료할 수 있다.
마지막으로 정렬을 완료한 배열을 하나씩 출력해주면 해결이다.
